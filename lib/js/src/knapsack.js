// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE
'use strict';

var List    = require("bs-platform/lib/js/list.js");
var Block   = require("bs-platform/lib/js/block.js");
var Curry   = require("bs-platform/lib/js/curry.js");
var BatList = require("bs-batteries/lib/js/src/batList.js");

function Make(funarg) {
  var totalItemSize = function (param) {
    return List.fold_left((function (acc, i) {
                  return acc + Curry._1(funarg[/* size */0], i) | 0;
                }), 0, param);
  };
  var filledSpace = function (param) {
    return List.fold_left((function (total, item) {
                  return total + Curry._1(funarg[/* size */0], item) | 0;
                }), 0, param[/* items */1]);
  };
  var emptySpace = function (sack) {
    return sack[/* size */0] - filledSpace(sack) | 0;
  };
  var willFit = function (sack, item) {
    return +(Curry._1(funarg[/* size */0], item) <= emptySpace(sack));
  };
  var make = function (size) {
    return /* record */[
            /* size */size,
            /* items : [] */0
          ];
  };
  var map = function (f, sack) {
    var items = Curry._1(f, sack[/* items */1]);
    var match = +(totalItemSize(items) <= sack[/* size */0]);
    if (match !== 0) {
      return /* record */[
              /* size */sack[/* size */0],
              /* items */items
            ];
    } else {
      return sack;
    }
  };
  var bind = function (sack, f) {
    var newSack = Curry._1(f, sack);
    var match = +(totalItemSize(newSack[/* items */1]) <= newSack[/* size */0]);
    if (match !== 0) {
      return newSack;
    } else {
      return sack;
    }
  };
  var $$return = function (items) {
    return /* record */[
            /* size */totalItemSize(items),
            /* items */items
          ];
  };
  var append = function (sack, item) {
    var match = willFit(sack, item);
    if (match !== 0) {
      return /* Ok */Block.__(0, [/* record */[
                  /* size */sack[/* size */0],
                  /* items : :: */[
                    item,
                    sack[/* items */1]
                  ]
                ]]);
    } else {
      return /* Bad */Block.__(1, [sack]);
    }
  };
  var findBest_ = function (_i, sack, _items) {
    while(true) {
      var items = _items;
      var i = _i;
      if (items) {
        var fits = willFit(sack, items[0]);
        if (fits !== 0) {
          return /* Some */[i];
        } else {
          _items = items[1];
          _i = i + 1 | 0;
          continue ;
          
        }
      } else {
        return /* None */0;
      }
    };
  };
  var findBest = function (sack, items) {
    return findBest_(0, sack, items);
  };
  var pluckItem = function (items, i) {
    return /* tuple */[
            BatList.at(items, i),
            BatList.remove_at(i, items)
          ];
  };
  var packItem = function (i, sack, items) {
    var match = pluckItem(items, i);
    var match$1 = append(sack, match[0]);
    if (match$1.tag) {
      return /* tuple */[
              sack,
              items
            ];
    } else {
      return /* tuple */[
              match$1[0],
              match[1]
            ];
    }
  };
  var pack = function (_sack, _items) {
    while(true) {
      var items = _items;
      var sack = _sack;
      var match = findBest_(0, sack, items);
      if (match) {
        var match$1 = packItem(match[0], sack, items);
        _items = match$1[1];
        _sack = match$1[0];
        continue ;
        
      } else {
        return /* tuple */[
                sack,
                items
              ];
      }
    };
  };
  return /* module */[
          /* make */make,
          /* map */map,
          /* bind */bind,
          /* >>= */bind,
          /* return */$$return,
          /* append */append,
          /* findBest */findBest,
          /* pack */pack
        ];
}

function size(param) {
  return param[/* weight */0];
}

function sort(param, param$1) {
  var s1 = param$1[/* weight */0];
  var s0 = param[/* weight */0];
  var match = +(s0 === s1);
  if (match !== 0) {
    return param[/* value */1] - param$1[/* value */1] | 0;
  } else {
    return s0 - s1 | 0;
  }
}

var BasicItem = /* module */[
  /* size */size,
  /* sort */sort
];

function totalItemSize(param) {
  return List.fold_left((function (acc, i) {
                return acc + size(i) | 0;
              }), 0, param);
}

function filledSpace(param) {
  return List.fold_left((function (total, item) {
                return total + size(item) | 0;
              }), 0, param[/* items */1]);
}

function emptySpace(sack) {
  return sack[/* size */0] - filledSpace(sack) | 0;
}

function willFit(sack, item) {
  return +(size(item) <= emptySpace(sack));
}

function make(size) {
  return /* record */[
          /* size */size,
          /* items : [] */0
        ];
}

function map(f, sack) {
  var items = Curry._1(f, sack[/* items */1]);
  var match = +(totalItemSize(items) <= sack[/* size */0]);
  if (match !== 0) {
    return /* record */[
            /* size */sack[/* size */0],
            /* items */items
          ];
  } else {
    return sack;
  }
}

function bind(sack, f) {
  var newSack = Curry._1(f, sack);
  var match = +(totalItemSize(newSack[/* items */1]) <= newSack[/* size */0]);
  if (match !== 0) {
    return newSack;
  } else {
    return sack;
  }
}

function $$return(items) {
  return /* record */[
          /* size */totalItemSize(items),
          /* items */items
        ];
}

function append(sack, item) {
  var match = willFit(sack, item);
  if (match !== 0) {
    return /* Ok */Block.__(0, [/* record */[
                /* size */sack[/* size */0],
                /* items : :: */[
                  item,
                  sack[/* items */1]
                ]
              ]]);
  } else {
    return /* Bad */Block.__(1, [sack]);
  }
}

function findBest_(_i, sack, _items) {
  while(true) {
    var items = _items;
    var i = _i;
    if (items) {
      var fits = willFit(sack, items[0]);
      if (fits !== 0) {
        return /* Some */[i];
      } else {
        _items = items[1];
        _i = i + 1 | 0;
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function findBest(sack, items) {
  return findBest_(0, sack, items);
}

function pluckItem(items, i) {
  return /* tuple */[
          BatList.at(items, i),
          BatList.remove_at(i, items)
        ];
}

function packItem(i, sack, items) {
  var match = pluckItem(items, i);
  var match$1 = append(sack, match[0]);
  if (match$1.tag) {
    return /* tuple */[
            sack,
            items
          ];
  } else {
    return /* tuple */[
            match$1[0],
            match[1]
          ];
  }
}

function pack(_sack, _items) {
  while(true) {
    var items = _items;
    var sack = _sack;
    var match = findBest_(0, sack, items);
    if (match) {
      var match$1 = packItem(match[0], sack, items);
      _items = match$1[1];
      _sack = match$1[0];
      continue ;
      
    } else {
      return /* tuple */[
              sack,
              items
            ];
    }
  };
}

var BasicKnapsack = /* module */[
  /* make */make,
  /* map */map,
  /* bind */bind,
  /* >>= */bind,
  /* return */$$return,
  /* append */append,
  /* findBest */findBest,
  /* pack */pack
];

exports.Make          = Make;
exports.BasicItem     = BasicItem;
exports.BasicKnapsack = BasicKnapsack;
/* BatList Not a pure module */
