// Generated by BUCKLESCRIPT VERSION 1.9.3, PLEASE EDIT WITH CARE
'use strict';

var List    = require("bs-platform/lib/js/list.js");
var Curry   = require("bs-platform/lib/js/curry.js");
var Option  = require("bs-batteries/lib/js/src/option.js");
var BatList = require("bs-batteries/lib/js/src/batList.js");

function Make(I) {
  var filledSpace = function (param) {
    return List.fold_left((function (total, item) {
                  return total + Curry._1(I[/* size */0], item) | 0;
                }), 0, param[/* items */1]);
  };
  var emptySpace = function (sack) {
    return sack[/* size */0] - filledSpace(sack) | 0;
  };
  var willFit = function (sack, item) {
    return +(Curry._1(I[/* size */0], item) <= emptySpace(sack));
  };
  var append = function (sack, item) {
    var itemSize = Curry._1(I[/* size */0], item);
    var match = willFit(sack, item);
    if (match !== 0) {
      return /* Some */[/* record */[
                /* size */sack[/* size */0] + itemSize | 0,
                /* items : :: */[
                  item,
                  sack[/* items */1]
                ]
              ]];
    } else {
      return /* None */0;
    }
  };
  var findBest = function (sack, items) {
    var _i = 0;
    var sack$1 = sack;
    var _items = List.sort(I[/* sort */1], items);
    while(true) {
      var items$1 = _items;
      var i = _i;
      if (items$1) {
        var match = willFit(sack$1, items$1[0]);
        if (match !== 0) {
          return /* Some */[i];
        } else {
          _items = items$1[1];
          _i = i + 1 | 0;
          continue ;
          
        }
      } else {
        return /* None */0;
      }
    };
  };
  var pack = function (_sack, _items) {
    while(true) {
      var items = _items;
      var sack = _sack;
      var match = findBest(sack, items);
      if (match) {
        var i = match[0];
        var item = BatList.at(items, i);
        var s = Option.$$default(sack, append(sack, item));
        var match$1 = willFit(sack, item);
        var xs = match$1 !== 0 ? BatList.remove_at(i, items) : items;
        _items = xs;
        _sack = s;
        continue ;
        
      } else {
        return /* tuple */[
                sack,
                items
              ];
      }
    };
  };
  return /* module */[
          /* append */append,
          /* findBest */findBest,
          /* pack */pack
        ];
}

function size(param) {
  return param[/* weight */0];
}

function sort(param, param$1) {
  var s1 = param$1[/* weight */0];
  var s0 = param[/* weight */0];
  var match = +(s0 === s1);
  if (match !== 0) {
    return param[/* value */1] - param$1[/* value */1] | 0;
  } else {
    return s0 - s1 | 0;
  }
}

var BasicItem = /* module */[
  /* size */size,
  /* sort */sort
];

function filledSpace(param) {
  return List.fold_left((function (total, item) {
                return total + size(item) | 0;
              }), 0, param[/* items */1]);
}

function emptySpace(sack) {
  return sack[/* size */0] - filledSpace(sack) | 0;
}

function willFit(sack, item) {
  return +(size(item) <= emptySpace(sack));
}

function append(sack, item) {
  var itemSize = size(item);
  var match = willFit(sack, item);
  if (match !== 0) {
    return /* Some */[/* record */[
              /* size */sack[/* size */0] + itemSize | 0,
              /* items : :: */[
                item,
                sack[/* items */1]
              ]
            ]];
  } else {
    return /* None */0;
  }
}

function findBest(sack, items) {
  var _i = 0;
  var sack$1 = sack;
  var _items = List.sort(sort, items);
  while(true) {
    var items$1 = _items;
    var i = _i;
    if (items$1) {
      var match = willFit(sack$1, items$1[0]);
      if (match !== 0) {
        return /* Some */[i];
      } else {
        _items = items$1[1];
        _i = i + 1 | 0;
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function pack(_sack, _items) {
  while(true) {
    var items = _items;
    var sack = _sack;
    var match = findBest(sack, items);
    if (match) {
      var i = match[0];
      var item = BatList.at(items, i);
      var s = Option.$$default(sack, append(sack, item));
      var match$1 = willFit(sack, item);
      var xs = match$1 !== 0 ? BatList.remove_at(i, items) : items;
      _items = xs;
      _sack = s;
      continue ;
      
    } else {
      return /* tuple */[
              sack,
              items
            ];
    }
  };
}

var BasicKnapsack = /* module */[
  /* append */append,
  /* findBest */findBest,
  /* pack */pack
];

exports.Make          = Make;
exports.BasicItem     = BasicItem;
exports.BasicKnapsack = BasicKnapsack;
/* BatList Not a pure module */
